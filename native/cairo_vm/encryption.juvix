module encryption;

import Stdlib.Prelude open;
import Stdlib.Cairo.Ec as Ec;
import Stdlib.Cairo.Poseidon open;
import Stdlib.Debug as Debug;

type Cipher :=
  mkCipher@{
    cipher_text : List Field;
    cur_state : Field
  };

update_poseidon_state (cur_msg secret_key_x : Field) (cipher : Cipher) : Cipher :=
  let
    new_state := Cipher.cur_state cipher + cur_msg;
    new_text := new_state :: Cipher.cipher_text cipher;
  in mkCipher@{
    cipher_text := new_text;
    cur_state := poseidonHash2 new_state secret_key_x
  };

generate_cipher (poseidon_state : Field) (secret_key_x : Field) (plaintext : List Field) : Cipher :=
  let
    go (cipher : Cipher) : List Field -> Cipher
      | [] := cipher@Cipher{cipher_text := reverse (Cipher.cipher_text cipher)}
      | (m :: ms) := go (update_poseidon_state m secret_key_x cipher) ms;
  in go
    mkCipher@{
      cipher_text := [];
      cur_state := poseidon_state
    }
    plaintext;

-- pad_messages
--   (messages : List Field)
--   : List Field :=
--   let
--     n : Nat := length messages;
--   in if
--     | n < 10 := messages ++ replicate (10 - n) 0;
--     | n == 10 := messages;
--     | else := take 10 messages;

encryption
  (messages : List Field) (pk_x : Field) (pk_y : Field) (sk : Field) (nonce : Field) : List Field :=

  let
    -- Generate encryption key
    pk := Ec.mkPoint pk_x pk_y;
    secret_key := Ec.mul sk pk;

    -- PLAINTEXT_NUM := 10;

    -- TODO: Pad the messages here or outside of the circuit?
    plaintext := messages;

    -- Init poseidon state
    secret_key_x := Ec.Point.x secret_key;
    poseidon_state := poseidonHashList [secret_key_x; Ec.Point.y secret_key; nonce; 10];

    -- Generate cipher
    final_cipher := generate_cipher poseidon_state secret_key_x plaintext;

    -- Get MAC
    mac := Cipher.cur_state final_cipher;

    -- Generate sender's pk
    generator := Ec.mkPoint Ec.StarkCurve.GEN_X Ec.StarkCurve.GEN_Y;
    sender_pk := Ec.mul sk generator;

  in Cipher.cipher_text final_cipher ++ [mac; Ec.Point.x sender_pk; Ec.Point.y sender_pk; nonce];

type List10 :=
  mkList10@{
    elem0 : Field;
    elem1 : Field;
    elem2 : Field;
    elem3 : Field;
    elem4 : Field;
    elem5 : Field;
    elem6 : Field;
    elem7 : Field;
    elem8 : Field;
    elem9 : Field
  };

main (messages : List Field) (pk_x : Field) (pk_y : Field) (sk : Field) (nonce : Field) : List10 :=
  case encryption messages pk_x pk_y sk nonce of
    | [elem0; elem1; elem2; elem3; elem4; elem5; elem6; elem7; elem8; elem9] :=
      mkList10@{
        elem0;
        elem1;
        elem2;
        elem3;
        elem4;
        elem5;
        elem6;
        elem7;
        elem8;
        elem9
      }
    | _ := mkList10 0 0 0 0 0 0 0 0 0 0;
